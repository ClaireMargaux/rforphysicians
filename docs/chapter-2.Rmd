---
title: "Chapter 2"
date: "`r Sys.Date()`"
contact: claire.descombes@insel.ch
output:
  html_document:
    toc: yes
    toc_float: yes
    number_sections: yes
    df_print: paged
    theme: paper
    code_folding: show
    math_method: katex
subtitle: "R for physicians"
bibliography: C:/GitHub/rforphysicians/docs/Rforphysicians.bib
link-citations: yes
editor_options: 
  chunk_output_type: console
knit: (function(input, ...) {rmarkdown::render(input)})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  message = FALSE, 
  fig.height = 5,
  fig.width = 6,
  eval = TRUE
)
library(tidyverse)
```

| Author           |                                                                 |
|:-----------------|:----------------------------------------------------------------|
| Name             | Claire Descombes                                                |
| Affiliation      | Universit√§tsklinik f√ºr Neurochirurgie, Inselspital Bern         |
| Degree           | MSc Statistics and Data Science, University of Bern             |
| Contact          | [claire.descombes@insel.ch](mailto:claire.descombes@insel.ch)   |

The reference material for this course, as well as some useful literature to deepen your knowledge of R, can be found at the bottom of the page.

# Importing data

## Working directory

When you want to load a file (e.g. a dataset), you have two options:

* Put the file inside your **R working directory** (see below), so you don't need to specify the full path.
* Store the file somewhere else, and then always give the full (or relative) path when importing it.

If your file is stored in the folder that is currently set as your working directory, you can simply write:

```{r, eval = FALSE}
setwd("C:/path/to/your/folder/")
data <- read.csv("testdata.csv")

# This is convenient because you can move the entire folder around without 
# breaking your code: as long as you set the working directory to that folder 
# when you open the script, everything still works.
```

If you want some structure inside your project (e.g. datasets stored in a subfolder "datasets"), you can use relative paths, which always start from the working directory:

```{r, eval=FALSE}
setwd("C:/path/to/your/folder/")
data <- read.csv("datasets/testdata.csv")

# This is safe and portable: moving the whole folder keeps the relative paths valid.
```

If your files are scattered across your computer, you may prefer to specify the absolute path each time:

```{r, eval = FALSE}
data <- read.csv("C:/some/other/folder/testdata.csv")

# This avoids having to change the working directory, but: the code breaks if 
# the file moves, and the script is harder to share with others (everyone has 
# different folder structures).
```

**Working directory**

To tell R which folder you are working in (e.g., where your data is stored), you have several options:

  + Go to the tab *Session > Set Working Directory > Choose Directory* and select your folder manually.
  + Use `setwd("C:/path/to/your/folder")` in your script/console.
  + Or, the most convenient for script-based work: go to *Session > Set Working Directory > To Source File Location* to automatically set the working directory to the location of your script.

```{r, eval=FALSE}
# Command to display the current working directory
getwd()

# Command to manually set your working directory
setwd("C:/path/to/your/folder")

# Command to automatically set your working directory to the location of your R file
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 
```

## Import CSV and xlsx data

We will first look at how to import a CSV file into R as a data frame.

### CSV

CSV stands for Comma-Separated Values. In a `.csv` file, the values are stored as plain text, separated by commas. This is a simple and widely used format for storing tabular data.

After setting your working directory or determining the path to your CSV file, you can use the `read.csv()` function to import the data. This will create a data frame, which is one of the most commonly used structures in R for handling datasets.

üí° I recommend to use data frames as data type for your data: they are generally easier to work with than matrices, especially for beginners.

```{r, eval=FALSE}
# Import a CSV file into a data frame
dataset <- read.csv("C:/path/to/your/folder/data.csv")
```

The function `read.csv()` has several useful arguments:

```
read.csv(file, header = TRUE, sep = ",", quote = "\"",
         dec = ".", fill = TRUE, comment.char = "", row.names, 
         stringsAsFactors, ...)
```

  + `header`: A logical value (`TRUE/FALSE`) indicating whether the file contains the names of the variables as its first line. If missing, the value is determined from the file format: header is set to `TRUE` if the first row contains one fewer field than the number of columns.

  + `sep`: The field separator used in the file. For `read.csv()`, the default is a comma (`,`), which is standard for CSV files.
  
  + `row.names`: Specifies the row names of the data frame. It can be:
    + a vector of row names,
    + a number indicating the column to use as row names,
    + a character string naming the column with row names.
    
    If a header is present and the first row has one fewer field than the number of columns, the first column is used as row names.
    Otherwise, rows are automatically numbered. Use `row.names = NULL` to force default numbering.
  
  + `col.names`: Optional vector of column names. If not provided, default names like "V1", "V2", etc., are assigned.
  
  + `stringsAsFactors`: `TRUE/FALSE`; should character vectors be converted to factors?

### XLS

Another widely used data format is the Excel file (`.xlsx` or `.xls`). For these, you can use the `readxl` package to import the data:

```{r, eval=FALSE}
# Load the readxl package (after installing it)
library(readxl)

# Read the first sheet of an Excel file
dataset <- read_excel("C:/path/to/your/folder/data.xlsx")
```

The function `read_excel()` also has several useful arguments:

```
read_excel(path, sheet = NULL, range = NULL,
  col_names = TRUE, col_types = NULL, na = "",...
)
```

+  `path`: Path to the xls/xlsx file.

+  `sheet`: Sheet to read. Either a string (the name of a sheet), or an integer (the position of the sheet). Ignored if the sheet is specified via range. If neither argument specifies the sheet, defaults to the first sheet.

+  `range`: A cell range to read from, as described in cell-specification. Includes typical Excel ranges like "B3:D87", possibly including the sheet name like "Budget!B2:G14", and more. 

+  `col_names`: `TRUE` to use the first row as column names, `FALSE` to get default names, or a character vector giving a name for each column.

+  `col_types`: Either `NULL` to guess all from the spreadsheet or a character vector containing one entry per column from these options: "skip", "guess", "logical", "numeric", "date", "text" or "list".

+  `na`: Character vector of strings to interpret as missing values. By default, `readxl` treats blank cells as missing data.

‚ö†Ô∏è Note: If your file is actually a CSV but mistakenly has a `.xlsx` extension, you should rename it to `.csv` and use `read.csv()` instead. Mixing up formats can lead to import errors.

### Load the NHANES data sets

Let us now look at real data frames to learn how to call or modify their elements. To do this, we will use multiple health data sets from the National Health and Nutrition Examination ([`NHANES`](https://www.cdc.gov/nchs/nhanes/)) Survey from 2011-2012. The survey assessed overall health and nutrition of adults and children in the United States and was conducted by the National Center for Health Statistics (NCHS). The data sets can be found in the [`data_sets` folder](https://github.com/ClaireMargaux/rforphysicians/tree/main/data_sets). More details on these data sets can be found in the Appendix A.

```{r, echo=FALSE}
# Load the necessary CSV files into data frames
demo <- read.csv("C:/GitHub/rforphysicians/data_sets/DEMO_G.csv") # Demographics (cycle G = 2011‚Äì2012)
bpx  <- read.csv("C:/GitHub/rforphysicians/data_sets/BPX_G.csv") # Blood pressure
bmx  <- read.csv("C:/GitHub/rforphysicians/data_sets/BMX_G.csv") # Body measures
smq  <- read.csv("C:/GitHub/rforphysicians/data_sets/SMQ_G.csv") # Smoking questionnaire
```

## Exercises

### Exercise 1

‚úèÔ∏è Exercise 1: import the `demo`, `bpx`, `bmx` and `smq` data sets from the [`data_sets` folder](https://github.com/ClaireMargaux/rforphysicians/tree/main/data_sets) into R.

# Handling data

## Base R vs `tidyverse`

Base R, without any additional packages, already provides many functions that are very handy for data handling. However, some contributed packages make data preparation much easier and more readable.

I‚Äôll introduce two such packages here, before diving into concrete data handling examples. Both are part of a larger and very powerful collection of packages for data science called the `tidyverse`, which I use for nearly all my analyses.

üí° In the Appendix B, you will find a table containing useful functions from both Base R and the `tidyverse` that facilitate efficient data handling.

### The pipe

One of the most downloaded contributed extension packages of all times is `magrittr`. It provides a very useful operator, the forward pipe operator `%>%`, which passes the object on its left as the first argument to the function on its right. This is much easier to understand with an example.

```{r, eval=FALSE}
# The easiest way to get magrittr is to install the whole tidyverse
install.packages("tidyverse")
```

```{r}
# Once installed, a package has to be loaded to be used
library(tidyverse)
```

```{r}
library(tidyverse)

# Let's do the same operation twice: once using the pipe, once without

# No pipe:
str(c(1,2,3,4))

# With pipe:
c(1,2,3,4) %>%
  str()

# Not too exciting yet, but consider a more complex case:
summary(log(sqrt(na.omit(c(1, 4, NA, 16, 25)))))

# With the pipe, we can rewrite this more readably:
c(1, 4, NA, 16, 25) %>%
  na.omit() %>%
  sqrt() %>%
  log() %>%
  summary()
```

The pipe helps turn nested function calls into a sequence of simpler, linear steps. This makes code easier to read, write, and debug. The pipe becomes especially powerful when used with functions from the `dplyr` package for data manipulation.

### `dplyr`

Another helpful R package is `dplyr`. It is a grammar of data manipulation, providing a consistent set of verbs that helps solve the most common data manipulation challenges. 

Let‚Äôs illustrate this with a simple example. Our goal: Group the cars dataset (contained in base R) by speed groups (e.g. low/medium/high), and for each group, compute (1) the average stopping distance and (2) the number of observations.

```{r}
# Base R (no dplyr, no pipe)

cars$speed_group <- cut(cars$speed, breaks = c(0, 10, 20, 30), 
                        labels = c("Low", "Medium", "High"))

avg_dist <- aggregate(dist ~ speed_group, data = cars, mean)
n_obs <- aggregate(dist ~ speed_group, data = cars, length)
names(n_obs)[2] <- "n"

summary_df <- merge(avg_dist, n_obs, by = "speed_group")
summary_df
```

```{r}
# With dplyr, no pipe:

cars <- mutate(cars, speed_group = cut(speed, breaks = c(0, 10, 20, 30), 
                                       labels = c("Low", "Medium", "High")))

summary_df <- summarise(group_by(cars, speed_group),
                        avg_dist = mean(dist),
                        n = n())
summary_df
```

```{r}
# With dplyr and the pipe
cars %>%
  mutate(speed_group = cut(speed, breaks = c(0, 10, 20, 30), 
                           labels = c("Low", "Medium","High"))) %>%
  group_by(speed_group) %>%
  summarise(
    avg_dist = mean(dist),
    n = n()
  )
```

üí° `cut(x, ...)` divides the range of `x` into intervals (the `breaks`) and codes the values in x according to which interval they fall. `labels` are the levels of the resulting category. If `labels = FALSE`, simple integer codes are returned instead of a factor.

As you can see, using `dplyr` and the pipe can make your life much easier.

In the following chapter, we‚Äôll use both base R and `tidyverse` functions without always noting which package they belong to. If you're ever unsure, you can check the top-left corner of the function's help page.

```{r, echo=FALSE, out.width = "70%"}
knitr::include_graphics(path = "C:/GitHub/rforphysicians/docs/images/documentation.png")
```

## Accessing elements in data frames

Being able to access elements in a data frame is essential when working with data. Here are some common methods to select specific elements, rows, or columns.

```{r}
# Look at the first respectively last few rows
head(demo)
tail(demo)
```

üí° You can use the brackets `[]` to select specific rows and columns. Since data frames are bi-dimensional, the **first index refers to rows and the second to columns**. To select a particular column, you can omit the row index. To select a particular row, omit the column index. For example: `demo[, 1:10]` selects all rows of the first 10 columns, and `demo[, ]` simply returns the entire dataset, since neither rows nor columns are restricted.

üí° To inspect a single column, you can also use the dollar `$` symbol to access that column as a vector.

```{r}
# Select columns by name
demo[, c("RIDAGEYR", "RIAGENDR")]  # All rows in the age and gender columns
col <- c("RIDAGEYR", "RIAGENDR")
demo[, col]  # Alternative using predefined variable `col`
head(demo$RIDAGEYR)  # Returns the age column 

# Select rows by index
demo[1, ]  # Row 1 (all columns)

# Select specific elements by position
demo[1, 1]  # Access the first element of the first column (the respondent sequence number of the 1st participant)
ind_mat <- cbind(c(4, 3, 2), c(1, 4, 5))
demo[ind_mat]  # Access rows and columns using multiple indices

# Select rows based on a condition
demo[demo[, "RIDAGEYR"] > 50, ]  # Rows where age > 50
demo[demo[, "DMDHHSIZ"] < 3, ]  # Rows where total number of people in the household greater than 3
demo[demo[, "DMDHHSIZ"] >= 3, ]  # Rows where total number of people in the household greater or equal 3

# Combine logical vectors using "&" (AND), "|" (OR), and "!" (NOT)
demo[(demo[, "RIDAGEYR"] > 50 & demo[, "RIAGENDR"] == "Female"), ]  # Both conditions must be true
demo[(demo[, "DMDHHSIZ"] < 3 | demo[, "RIAGENDR"] == "Male"), ]  # One condition must be true
```

For those who are not familiar with combinations of logical vectors, here is a so-called truth table to help:

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics(path = "C:/GitHub/rforphysicians/docs/images/Truth_table.png")
```

### `dplyr` syntax

With `dplyr`, you can achieve the same things more readable, especially for filtering rows and selecting columns.

```{r}
# Select columns
select(demo, RIDAGEYR, RIAGENDR)

# Filter rows based on a condition
filter(demo, RIDAGEYR > 50)

# Combine filtering and selecting
filter(demo, RIDAGEYR > 50 & RIAGENDR == "Female") %>%
  select(RIDAGEYR, RIAGENDR)
```

üí° Using the pipe (`%>%`), the structure becomes more linear: first say what data you‚Äôre working on, then what to do with it.

```{r}
demo %>%
  filter(DMDHHSIZ < 3 | RIAGENDR == "Male") %>%
  select(DMDHHSIZ, RIAGENDR)
```

This syntax avoids nested brackets and makes your code easier to read, especially as operations grow more complex.

## Basic descriptive statistics

R makes it simple to compute basic descriptive statistics for exploring your dataset. Below are a few useful examples.

### Central tendency: mean and median

```{r}
mean(demo$RIDAGEYR, na.rm = TRUE)                 # Average (mean) age of participants
median(demo$DMDHHSIZ, na.rm = TRUE)               # Median household size
```

üí° The `na.rm` argument in those functions allows for ignoring the NA values.

With `dplyr`, you can combine `summarise()` with the pipe for clearer syntax:

```{r}
demo %>%
  summarise(mean_age = mean(RIDAGEYR, na.rm = TRUE),
            median_household_size = median(DMDHHSIZ, na.rm = TRUE))
```

### Dispersion: standard deviation, min, max, and range

```{r}
sd(demo$RIDAGEYR, na.rm = TRUE)                     # Standard deviation of age
range(demo$DMDHHSZA, na.rm = TRUE)                  # Range of number of young children
min(demo$DMDHRAGE, na.rm = TRUE)                    # Minimum age of household reference person
max(demo$DMDHRAGE, na.rm = TRUE)                    # Maximum age of household reference person
```

Also possible with `summarise()`:

```{r}
demo %>%
  summarise(sd_age = sd(RIDAGEYR, na.rm = TRUE),
            min_age = min(DMDHRAGE, na.rm = TRUE),
            max_age = max(DMDHRAGE, na.rm = TRUE))
```

### Frequency tables and proportions

```{r}
table(demo$RIAGENDR)                                # Gender
table(demo$RIDRETH1)                                # Race/Hispanic origin
prop.table(table(demo$DMDCITZN))                    # Citizenship status (proportions)
```

With `dplyr`, you get frequencies directly:

```{r}
demo %>%
  count(RIAGENDR)

demo %>%
  count(AIALANGA) %>%
  mutate(prop = n / sum(n))  # Proportional distribution
```

üí° `n()` gives the current group size.

### Group-wise summaries

```{r}
aggregate(DMDHRAGE ~ DMDHRMAR, data = demo, FUN = mean, na.rm = TRUE)   # Mean age of household reference person by marital status
aggregate(DMDHHSIZ ~ DMDHRGND, data = demo, FUN = median, na.rm = TRUE) # Median household size by gender of reference person
```

Or using `dplyr`:

```{r}
demo %>%
  group_by(DMDHRMAR) %>%
  summarise(mean_age = mean(DMDHRAGE, na.rm = TRUE))

demo %>%
  group_by(DMDHRGND) %>%
  summarise(median_household_size = median(DMDHHSIZ, na.rm = TRUE))
```

### Full overview

```{r}
summary(demo)[,1:5] # only for the first 5 variables
```

## Modifying elements in data frames

Now, let us assume we want to modify/add/remove one or multiple entries/rows/columns in our data frame. The brackets really come in handy now. In this setting, I recommend defining a new data frame before modifying the original one.

Some examples follow.

```{r}
# Modify one entry:
demo_mod <- demo  # Create a copy to avoid modifying the original data set
demo_mod[1, 1:5]
demo_mod[1, "RIAGENDR"] <- 'Female' # Change gender of the first participant
demo_mod[1, 1:5]

# Modify multiple entries based on a condition:
demo_mod[1:10, 1:5]
demo_mod[!is.na(demo_mod$RIDAGEYR) & demo_mod$RIDAGEYR < 18, ]$RIDAGEYR <- 18  # Set minimum age to 18
demo_mod[1:10, 1:5]
```

### `dplyr` syntax

With `mutate()` and `case_when()` from `dplyr`, the logic becomes slightly more readable, especially for multiple conditions:

```{r}
demo_mod <- demo %>%
  mutate(RIDAGEYR = case_when(
    !is.na(RIDAGEYR) & RIDAGEYR < 18 ~ 18,
    TRUE ~ RIDAGEYR  # leave other values unchanged
  ))
```

üí° `case_when()` is like a vectorised `ifelse()` on steroids ‚Äî it's handy for multiple conditions and clear logic.

## Dealing with NAs

Handling missing data (NAs) is a common task in data analysis. Before deciding how to treat them, it's important to understand where and how often they occur.

```{r}
colSums(is.na(demo))              # Number of NAs per column
sum(complete.cases(demo))         # Number of rows without any NAs
```

üí° `is.na()` returns a logical matrix where `TRUE` indicates a missing value (`NA`) and `FALSE` indicates a non-missing value. `colSums()` takes this logical matrix and sums up the `TRUE` values (which are treated as 1), giving you the count of missing values for each column.

üí° `complete.cases()` returns a logical vector: TRUE if a row has no missing values, and FALSE otherwise. Using `sum(complete.cases(...))` counts the number of rows with no missing data.

One way to handle missing data is to remove rows containing NAs for the variable(s) you are interested in. This can be appropriate in some cases, but it should be done with care, as it may introduce bias or reduce sample size. We‚Äôll discuss this further in Chapter 5.

```{r}
# Remove rows with any missing values in the DMDHRMAR column
demo_DMDHRMAR <- demo[!is.na(demo$DMDHRMAR), ]

# Check for missing values
sum(is.na(demo_DMDHRMAR$DMDHRMAR))
```

You can remove all rows with missing values across any of the columns in the dataset using the function `na.omit()`.

```{r}
# Remove rows with missing values in any column
demo_no_na <- na.omit(demo)

# Check the resulting data frame and its structure
head(demo_no_na)
```

üí° For our `demo` data set, this removes all the rows! Another reminder to be very careful when removing NA values.

### `dplyr` syntax

The `filter()` function makes row-wise filtering more intuitive:

```{r}
# Keep only rows where DMDHRMAR is not missing
demo_DMDHRMAR <- demo %>%
  filter(!is.na(DMDHRMAR))

# Remove all rows with any missing values
demo_no_na <- demo %>%
  filter(complete.cases(.))
```

üí° Using `filter()` keeps the logic clear and readable, especially when chaining multiple conditions with the pipe.

## Exercises

### Exercise 2

‚úèÔ∏è Exercise 2: inspect the structure of the `demo` data set, look at different entries and familiarize yourself with the commands. Here are a few possible tasks, but try doing a few more of your own.

1. View the first few rows of the dataset

2. Display the names of all columns

3. View all unique values in the race column

4. Count how many people are married in the dataset (absolute counts and proportions)

5. Get a quick statistical summary of a few columns (e.g. age, total number of people in the family and age of the household reference person)

6. View the number of missing values in each column

7. Calculate the average age of the cohort

8. Calculate the median total number of people in the household by race

### Exercise 3

‚úèÔ∏è Exercise 3: generate a new data frame selecting only the female patients that are above 18 years old and that took the ACASI interview in Spanish.

# Combining data

In practice, data is often spread across multiple data frames that need to be combined. Depending on the structure and goal, there are different ways to combine data frames:

## Column binding 

To add columns side-by-side, the data frames must have the same number of rows.

```{r}
# Extract one column from demo to create an additional data frame with the same 
# number of rows
extra_info <- demo$RIDRETH1

# Combine using cbind
combined_df <- cbind(demo, extra_info)
combined_df[1, ]

# Add a new column directly to demo with mutate() from dplyr
combined_df <- demo %>%
  mutate(extra_info = RIDRETH1)
combined_df[1, ]

# You can even choose where your new column should go
# e.g. right after the SEQN column
combined_df <- demo %>%
  mutate(extra_info = RIDRETH1) %>%
  relocate(extra_info, .after = SEQN)
combined_df[1, ]
```

## Row binding

To stack data frames vertically, the data frames must have the same column names and types.

```{r}
# Extract one row from demo to create an additional data frame with the same 
# structure (column names and types)
(new_participant <- demo[18,])

# Combine using rbind
extended_df <- rbind(demo, new_participant)
extended_df[nrow(extended_df),]

# Alternative with dplyr (bind_rows())
extended_df <- bind_rows(demo, new_participant)
extended_df %>%
  slice(n())  # Show last row

# Here again, you could choose a specific position for your new row
# e.g. the second row
extended_df <- 
  bind_rows(
    demo %>% slice(1),
    new_participant,
    demo %>% slice(2:n())
  )
extended_df[1:2, ]
```

üí° `n()` gives the current group size. `slice()` lets you index rows by their (integer) locations. 

## Merging / Joins

The function `merge()` combines data frames based on a common column, similar to SQL joins (see figure below for a reminder on the different types of joins).

```{r}
# Merge two data frames by participant ID `SEQN` (inner join by default)
merged_demo_bpx <- merge(demo, bpx, by = "SEQN")
merged_demo_bpx[1, ]

# In base R, you can use the Reduce() function to iteratively merge a list of data frames
data_list <- list(demo, bpx, bmx) # list of data frames to merge
merged_demo_bpx_bmx <- Reduce(function(x, y) merge(x, y, by = "SEQN"), data_list) # perform an inner join on all data frames by 'SEQN'
``` 

You should specify the type of join you are looking for:

  + Inner join (default): keep only rows with matching `SEQN` in both data frames: `inner_join_df <- merge(demo, bmx, by = "SEQN")`
  + Left (outer) join: keep all rows from `demo` and only matching rows from `bmx`: `left_join_df <- merge(demo, bmx, by = "SEQN", all.x = TRUE)`
  + Right (outer) join: keep all rows from `bmx` and only matching rows from `demo`: `left_join_df <- merge(demo, bmx, by = "SEQN", all.y = TRUE)`
  + Full (outer) join: keep all rows from both `demo` and `bmx`, filling with NA where there are no matches: `full_join_df <- merge(demo, bmx, by = "SEQN", all = TRUE)`

The joins are **identical** if both tables contain exactly the same set of keys (perfect matching, no extra rows).

```{r, echo=FALSE, out.width = "100%"}
knitr::include_graphics(path = "C:/GitHub/rforphysicians/docs/images/types_of_joins.jpg")
```

üí° `merge()` in base R is flexible but can be a bit verbose. For simpler syntax, you can also use the `dplyr` functions `left_join()`, `right_join()`, `inner_join()`, and `full_join()`.

```{r}
# Inner join
inner_join_df <- demo %>%
  inner_join(bmx, by = "SEQN")

# Left join
left_join_df <- demo %>%
  left_join(bmx, by = "SEQN")

# Right join
right_join_df <- demo %>%
  right_join(bmx, by = "SEQN")

# Full join
full_join_df <- demo %>%
  full_join(bmx, by = "SEQN")
```

## Exercises

### Exercise 4

‚úèÔ∏è Exercise 4: merge the 4 data sets `demo`, `bpx`, `bmx` and `smq` into a single data set `merged_nhanes` by performing an inner join on the `SEQN` ID and using the `dplyr` package.

# Saving data

You can save data sets in different formats, depending on how you want to use them later:

  + CSV ‚Äì human-readable and widely supported (e.g. by Excel, Python, etc.)
  + RDS ‚Äì R-specific format for saving a single R object (more compact than CSV, preserves data types)
  + RData ‚Äì used to save multiple R objects into a single file

Let us save a data frame in all those different formats.

```{r, eval=FALSE}
# Specify the directory for the data
directory <- "C:/GitHub/rforphysicians/data_sets/"

# Save as CSV
write.csv(merged_demo_bpx_bmx, file = file.path(directory,"merged_demo_bpx_bmx.csv"), row.names = FALSE)

# Save as RDS (recommended for re-loading in R)
saveRDS(merged_demo_bpx_bmx, file = file.path(directory,"merged_demo_bpx_bmx.rds"))

# Save as RData (can contain multiple objects)
save(merged_demo_bpx_bmx, file = file.path(directory,"merged_demo_bpx_bmx.RData"))
```

üí° `file.path()` constructs the path to a file from components in a platform-independent way. It concatenates paths and file names, and automatically uses the correct file separator (/ on Linux and macOS, \\ on Windows), making your code more robust and portable.

```{r}
directory <- "C:/GitHub/rforphysicians/data_sets/"
(path <- file.path(directory,"merged_demo_bpx_bmx.csv"))
```

You can load these later using:

```{r, eval=FALSE}
# Specify the directory for the data
directory <- "C:/GitHub/rforphysicians/data_sets/" 

# Read CSV
df_csv <- read.csv(file.path(directory, "merged_demo_bpx_bmx.csv"))

# Alternative: use package readr from tidyverse
df_csv2 <- read_csv(file.path(directory, "merged_demo_bpx_bmx.csv"))

# Read RDS
df_rds <- readRDS(file.path(directory, "merged_demo_bpx_bmx.rds"))

# Load RData (loads objects into the environment, no assignation with `<-` needed)
load(file.path(directory, "merged_demo_bpx_bmx.RData"))
```

üí° Check which objects are loaded with `ls()` (returns a vector of character strings giving the names of the objects in the specified environment).

```{r}
ls()
```

## Exercises

### Exercise 5

‚úèÔ∏è Exercise 5: Save the data frame resulting from Exercise 4 in your working directory in .csv, .rds and .RData formats.

# Solutions to the exercises

Please note that those are only examples, there are always many ways to solve the same task!

## Exercise 1

‚òëÔ∏è Exercise 1: 

Start by downloading the different CSV files on your laptop, ideally in the same folder as your script.

```{r}
# Load the necessary CSV files into data frames

directory <- "C:/GitHub/rforphysicians/data_sets/" # Your files' directory here

demo <- read.csv(paste0(directory,"DEMO_G.csv"))  # Demographics (cycle G = 2011‚Äì2012)
bpx  <- read.csv(paste0(directory,"BPX_G.csv"))   # Blood pressure
bmx  <- read.csv(paste0(directory,"BMX_G.csv"))   # Body measures
smq  <- read.csv(paste0(directory,"SMQ_G.csv"))   # Smoking questionnaire

# Or simply set your working directory to "source file location", then if you 
# indeed placed your data in the same folder as your script, you do not even 
# have to precise the directory:
# demo <- read.csv("DEMO_G.csv")
```

## Exercise 2

‚òëÔ∏è Exercise 2: Did you manage to select a specific column you were interested in? Were you able to check the number or proportions of entries for a few variables? Be creative :)

Here are solutions for the few example tasks.

```{r}
# 1) View the first few rows of the dataset
head(demo)

# 2) Display the names of all columns
names(demo)

# 3) View all unique values in the race column
unique(demo$RIDRETH1)

# 4) Count how many people are married in the dataset
# (absolute counts and proportions)
married <- demo %>%
  mutate(DMDMARTL = ifelse(DMDMARTL == "Married", "married", "other")) %>%
  select(DMDMARTL)
table(married)
prop.table(table(married))
  
# 5) Get a quick statistical summary of a few columns 
# (here age, total number of people in the family and age of the household reference person)
summary(demo[,c('RIDAGEYR','DMDFMSIZ','DMDHRAGE')])

# 6) View the number of missing values in each column
colSums(is.na(demo))

# 7) Calculate the average age of the cohort
mean(demo$RIDAGEYR, na.rm = TRUE)

# 8) Calculate the median total number of people in the household by race
demo %>%
  group_by(RIDRETH1) %>%
  summarise(median_people_household = median(DMDHHSIZ, na.rm = TRUE))
```

## Exercise 3

‚òëÔ∏è Exercise 3:

```{r}
# Filter the dataset to include only female patients that are above 18 years old 
# and that took the ACASI interview in Spanish
demo_filtered <- demo[demo$RIAGENDR == "Female" & 
                      demo$RIDAGEYR > 17 & 
                      !is.na(demo$AIALANGA) & demo$AIALANGA == "Spanish", ]
col <- c('RIAGENDR', 'RIDAGEYR', 'AIALANGA')
demo_filtered[, col]
```

üí° Note: When filtering on a variable that contains missing values (e.g., `AIALANGA`), you must explicitly exclude NAs using `!is.na(...)`. This is because comparisons like demo$AIALANGA == "Spanish" return NA for missing values, not FALSE, so those rows aren't properly excluded from the subset.

## Exercise 4

‚òëÔ∏è Exercise 4:

```{r}
# Load the dplyr package (should have been installed with tidyverse)
library(dplyr)

# Merge the datasets using inner joins by SEQN
data_list <- list(demo, bpx, bmx, smq)
merged_nhanes <- demo %>%
  inner_join(bpx, by = "SEQN") %>%
  inner_join(bmx, by = "SEQN") %>%
  inner_join(smq, by = "SEQN")
```

## Exercise 5

‚òëÔ∏è Exercise 5:

```{r, eval=FALSE}
# Save the merged dataset in your working directory
# Click on Session > Set Working Directory > To Source File Location, or use file.path()

results_directory <- "C:/GitHub/rforphysicians/data_sets"

write.csv(merged_nhanes, file.path(results_directory, "merged_nhanes.csv"), row.names = FALSE)
saveRDS(merged_nhanes, file.path(results_directory, "merged_nhanes.rds"))
save(merged_nhanes, file = file.path(results_directory, "merged_nhanes.RData"))
```

\newpage

# References

---
nocite: '@*'
...